<!DOCTYPE html>
<html>

<head>
  <link rel="help" href="https://drafts.csswg.org/css-scroll-snap-2/#snap-events" />
  <script src="/resources/testharness.js"></script>
  <script src="/resources/testharnessreport.js"></script>
  <script src="/dom/events/scrolling/scroll_support.js"></script>
</head>

<body>
  <style>
    #scroller {
      overflow: scroll;
      scroll-snap-type: y mandatory;
      height: 200px;
      width: 200px;
      border: solid 1px;
      position: absolute;
    }

    .snap_area {
      position: absolute;
      width: 100px;
      left: calc(50% - 50px);
    }

    #outer_snap_area {
      scroll-snap-align: start none;
      height: 1000px;
      background-color: blue;
    }

    #inner_snap_area {
      scroll-snap-align: start none;
      height: 100px;
      top: 100px;
      background-color: yellow;
    }
  </style>
  <div id="scroller">
    <div id="outer_snap_area" class="snap_area"></div>
    <div id="inner_snap_area" class="snap_area"></div>
  </div>
  <script>
    let scroller = document.getElementById("scroller");
    let resolve_func = null;
    let snap_targets_seen = [];

    async function reset(t) {
      inner_snap_area.style.height = "100px";
      inner_snap_area.style.scrollSnapAlign = "start none";
      outer_snap_area.style.scrollSnapAlign = "start none";
      scroller.style.scrollSnapType = "y mandatory";
      await resetTargetScrollState(t, scroller);
    }

    function store_snaptargets(evt) {
      for (const element of evt.snapTargets) {
        snap_targets_seen.push(element.id);
      }
      resolve_func();
    }

    async function setup(t) {
      await reset(t);
      await waitForCompositorCommit();
      t.step(() => {
        assert_equals(scroller.scrollTop, 0, "test precondition: scroller " +
            "is not scrolled.");
      });
      scroller.addEventListener("snapchanged", store_snaptargets);
      t.add_cleanup(() => {
        snap_targets_seen = [];
        scroller.removeEventListener("snapchanged", store_snaptargets);
      });
    }

    function assertSnapTargets(targets, msg) {
      assert_equals(targets.length, snap_targets_seen.length, msg);
      for (const target of targets) {
        assert_true(snap_targets_seen.includes(target,
            `${msg}: ${target} expected among snap targets`));
      }
    }
    promise_test(async (t) => {
      await setup(t);
      let target_snap_position = inner_snap_area.offsetTop +
          inner_snap_area.offsetHeight;
      // Scroll to an offset close to the bottom of the inner snap area and
      // expect to snap to an offset just below this snap area.
      let scrollend_promise = waitForScrollendEventNoTimeout(scroller);
      scroller.scrollTo(0, target_snap_position - 10);
      await scrollend_promise;
      assert_equals(scroller.scrollTop, target_snap_position,
          "scroller snaps to just below the inner snap area.");
      // We are just below the inner snap area. Increase its height so that it
      // is larger than the snapport and straddled by the snapport. Verify
      // that we snap to its bottom.
      let snapchanged_promise = new Promise(resolve => resolve_func = resolve);
      inner_snap_area.style.height =
        `${scroller.clientHeight + inner_snap_area.clientHeight - 10}px`;
      await snapchanged_promise;
      t.step(() => {
        assertSnapTargets([outer_snap_area.id, inner_snap_area.id],
            "both snap areas are covering the snapport and should be " +
            "considered snapped to");
      });
      target_snap_position = inner_snap_area.offsetTop +
          inner_snap_area.offsetHeight - scroller.clientHeight;
      assert_equals(scroller.scrollTop, target_snap_position,
          "scroller snaps to the bottom of the smaller snap area (which is " +
          "now covering).");
    }, "snapchanged fires after snap area is snapped to upon layout change.");

    promise_test(async (t) => {
      await setup(t);
      let target_snap_position = inner_snap_area.offsetTop +
          inner_snap_area.offsetHeight;
      // Scroll to an offset close to the bottom of the inner snap area and
      // expect to snap to an offset just below this snap area.
      let scrollend_promise = waitForScrollendEventNoTimeout(scroller);
      scroller.scrollTo(0, target_snap_position - 10);
      await scrollend_promise;
      assert_equals(scroller.scrollTop, target_snap_position,
        "scroller snaps to just below the inner snap area.");
      // We are just below the inner snap area. Increase its height so that it
      // is larger than the snapport making the current scroll position
      // a valid covering position within the inner snap area.
      let snapchanged_promise = new Promise(resolve => resolve_func = resolve);
      inner_snap_area.style.height =
          `${scroller.clientHeight + inner_snap_area.clientHeight + 10}px`;
      await snapchanged_promise;
      t.step(() => {
        assertSnapTargets([outer_snap_area.id, inner_snap_area.id],
        "both snap areas are covering the snapport and should be " +
        "considered snapped to");
      });
      assert_equals(scroller.scrollTop, target_snap_position,
        "scroller maintains offset which is now covering within inner area");
    }, "snapchanged fires after snap area is snapped to upon layout change " +
       "without scroll.");

    promise_test(async(t) => {
      await setup(t);
      await waitForCompositorCommit();
      let snapchanged_promise = new Promise(resolve => resolve_func = resolve);
      scroller.style.scrollSnapType = "none";
      await waitForCompositorCommit();
      await snapchanged_promise;
      t.step(() => {
        assertSnapTargets([],
        "scroller is no longer a snap container and should not be " +
        "snapped considered snapped");
      });
      snapchanged_promise = new Promise(resolve => resolve_func = resolve);
      scroller.style.scrollSnapType = "y mandatory";
      await snapchanged_promise;
      t.step(() => {
        assertSnapTargets([outer_snap_area.id],
            "scroller is a snap target again");
      });
    }, "snapchanged fires when container stops snapping");

    promise_test(async(t) => {
      await setup(t);
      await waitForCompositorCommit();
      let snapchanged_promise = new Promise(resolve => resolve_func = resolve);
      inner_snap_area.style.scrollSnapAlign = "none";
      outer_snap_area.style.scrollSnapAlign = "none";
      await waitForCompositorCommit();
      await snapchanged_promise;
      t.step(() => {
        assertSnapTargets([],
        "scroller no longer has snap areas  should not be " +
        "snapped considered snapped");
      });
      snapchanged_promise = new Promise(resolve => resolve_func = resolve);
      inner_snap_area.style.scrollSnapAlign = "start";
      outer_snap_area.style.scrollSnapAlign = "start";
      await snapchanged_promise;
      t.step(() => {
        assertSnapTargets([outer_snap_area.id],
            "scroller has snap areas again");
      });
    }, "snapchanged fires when snap container no longer has snap areas");
  </script>
</body>
</html>
